<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 11.0.0"/>
    <title>dynamixel_port API documentation</title>

    <style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
    <style>/*! syntax-highlighting.css */pre{line-height:125%;}span.linenos{color:inherit; background-color:transparent; padding-left:5px; padding-right:20px;}.pdoc-code .hll{background-color:#ffffcc}.pdoc-code{background:#f8f8f8;}.pdoc-code .c{color:#3D7B7B; font-style:italic}.pdoc-code .err{border:1px solid #FF0000}.pdoc-code .k{color:#008000; font-weight:bold}.pdoc-code .o{color:#666666}.pdoc-code .ch{color:#3D7B7B; font-style:italic}.pdoc-code .cm{color:#3D7B7B; font-style:italic}.pdoc-code .cp{color:#9C6500}.pdoc-code .cpf{color:#3D7B7B; font-style:italic}.pdoc-code .c1{color:#3D7B7B; font-style:italic}.pdoc-code .cs{color:#3D7B7B; font-style:italic}.pdoc-code .gd{color:#A00000}.pdoc-code .ge{font-style:italic}.pdoc-code .gr{color:#E40000}.pdoc-code .gh{color:#000080; font-weight:bold}.pdoc-code .gi{color:#008400}.pdoc-code .go{color:#717171}.pdoc-code .gp{color:#000080; font-weight:bold}.pdoc-code .gs{font-weight:bold}.pdoc-code .gu{color:#800080; font-weight:bold}.pdoc-code .gt{color:#0044DD}.pdoc-code .kc{color:#008000; font-weight:bold}.pdoc-code .kd{color:#008000; font-weight:bold}.pdoc-code .kn{color:#008000; font-weight:bold}.pdoc-code .kp{color:#008000}.pdoc-code .kr{color:#008000; font-weight:bold}.pdoc-code .kt{color:#B00040}.pdoc-code .m{color:#666666}.pdoc-code .s{color:#BA2121}.pdoc-code .na{color:#687822}.pdoc-code .nb{color:#008000}.pdoc-code .nc{color:#0000FF; font-weight:bold}.pdoc-code .no{color:#880000}.pdoc-code .nd{color:#AA22FF}.pdoc-code .ni{color:#717171; font-weight:bold}.pdoc-code .ne{color:#CB3F38; font-weight:bold}.pdoc-code .nf{color:#0000FF}.pdoc-code .nl{color:#767600}.pdoc-code .nn{color:#0000FF; font-weight:bold}.pdoc-code .nt{color:#008000; font-weight:bold}.pdoc-code .nv{color:#19177C}.pdoc-code .ow{color:#AA22FF; font-weight:bold}.pdoc-code .w{color:#bbbbbb}.pdoc-code .mb{color:#666666}.pdoc-code .mf{color:#666666}.pdoc-code .mh{color:#666666}.pdoc-code .mi{color:#666666}.pdoc-code .mo{color:#666666}.pdoc-code .sa{color:#BA2121}.pdoc-code .sb{color:#BA2121}.pdoc-code .sc{color:#BA2121}.pdoc-code .dl{color:#BA2121}.pdoc-code .sd{color:#BA2121; font-style:italic}.pdoc-code .s2{color:#BA2121}.pdoc-code .se{color:#AA5D1F; font-weight:bold}.pdoc-code .sh{color:#BA2121}.pdoc-code .si{color:#A45A77; font-weight:bold}.pdoc-code .sx{color:#008000}.pdoc-code .sr{color:#A45A77}.pdoc-code .s1{color:#BA2121}.pdoc-code .ss{color:#19177C}.pdoc-code .bp{color:#008000}.pdoc-code .fm{color:#0000FF}.pdoc-code .vc{color:#19177C}.pdoc-code .vg{color:#19177C}.pdoc-code .vi{color:#19177C}.pdoc-code .vm{color:#19177C}.pdoc-code .il{color:#666666}</style>
    <style>/*! theme.css */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f8f8f8;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}</style>
    <style>/*! layout.css */html, body{width:100%;height:100%;}html, main{scroll-behavior:smooth;}body{background-color:var(--pdoc-background);}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}header + main{margin-top:-3rem;}.git-button{display:none !important;}nav input[type="search"]{max-width:77%;}nav input[type="search"]:first-child{margin-top:-6px;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}header + main{margin-top:-4rem;}#navtoggle{display:none;}}#togglestate{position:absolute;height:0;}nav.pdoc{--pad:clamp(0.5rem, 2vw, 1.75rem);--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc > div > ul{margin-left:calc(0px - var(--pad));}nav.pdoc li a{padding:.2rem 0 .2rem calc(var(--pad) + var(--indent));}nav.pdoc > div > ul > li > a{padding-left:var(--pad);}nav.pdoc li{transition:all 100ms;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}</style>
    <style>/*! content.css */.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .pdoc-alert{padding:1rem 1rem 1rem calc(1.5rem + 24px);border:1px solid transparent;border-radius:.25rem;background-repeat:no-repeat;background-position:1rem center;margin-bottom:1rem;}.pdoc .pdoc-alert > *:last-child{margin-bottom:0;}.pdoc .pdoc-alert-note {color:#084298;background-color:#cfe2ff;border-color:#b6d4fe;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23084298%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8%2016A8%208%200%201%200%208%200a8%208%200%200%200%200%2016zm.93-9.412-1%204.705c-.07.34.029.533.304.533.194%200%20.487-.07.686-.246l-.088.416c-.287.346-.92.598-1.465.598-.703%200-1.002-.422-.808-1.319l.738-3.468c.064-.293.006-.399-.287-.47l-.451-.081.082-.381%202.29-.287zM8%205.5a1%201%200%201%201%200-2%201%201%200%200%201%200%202z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-warning{color:#664d03;background-color:#fff3cd;border-color:#ffecb5;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23664d03%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M8.982%201.566a1.13%201.13%200%200%200-1.96%200L.165%2013.233c-.457.778.091%201.767.98%201.767h13.713c.889%200%201.438-.99.98-1.767L8.982%201.566zM8%205c.535%200%20.954.462.9.995l-.35%203.507a.552.552%200%200%201-1.1%200L7.1%205.995A.905.905%200%200%201%208%205zm.002%206a1%201%200%201%201%200%202%201%201%200%200%201%200-2z%22/%3E%3C/svg%3E");}.pdoc .pdoc-alert-danger{color:#842029;background-color:#f8d7da;border-color:#f5c2c7;background-image:url("data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2224%22%20height%3D%2224%22%20fill%3D%22%23842029%22%20viewBox%3D%220%200%2016%2016%22%3E%3Cpath%20d%3D%22M5.52.359A.5.5%200%200%201%206%200h4a.5.5%200%200%201%20.474.658L8.694%206H12.5a.5.5%200%200%201%20.395.807l-7%209a.5.5%200%200%201-.873-.454L6.823%209.5H3.5a.5.5%200%200%201-.48-.641l2.5-8.5z%22/%3E%3C/svg%3E");}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-top:0;margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;background-color:var(--code);}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc > section:not(:first-of-type){margin-bottom:1.5rem;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{filter:opacity(1);}.pdoc details:not([open]){height:0;}.pdoc details > summary{position:absolute;top:-35px;right:0;font-size:.75rem;color:var(--muted);padding:0 .7em;user-select:none;cursor:pointer;}.pdoc details > summary:focus{outline:0;}.pdoc > section:first-of-type details > summary{top:-20px;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc .docstring .pdoc-code{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;user-select:none;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:.5rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}.pdoc table{display:block;width:max-content;max-width:100%;overflow:auto;margin-bottom:1rem;}.pdoc table th{font-weight:600;}.pdoc table th, .pdoc table td{padding:6px 13px;border:1px solid var(--accent2);}</style>
    <style>/*! custom.css */</style></head>
<body>
    <nav class="pdoc">
        <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
        <input id="togglestate" type="checkbox" aria-hidden="true" tabindex="-1">
        <div>




        <h2>API Documentation</h2>
            <ul class="memberlist">
            <li>
                    <a class="class" href="#DynamixelPort">DynamixelPort</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DynamixelPort.__init__">DynamixelPort</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.establish_connection">establish_connection</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.disconnect">disconnect</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_baudrate">set_baudrate</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_torque_enabled">set_torque_enabled</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_operating_mode">set_operating_mode</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_goal_pos">set_goal_pos</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_goal_vel">set_goal_vel</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.set_goal_current">set_goal_current</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_torque_enabled">get_torque_enabled</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_pos">get_pos</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_vel">get_vel</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_current">get_current</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_voltage">get_voltage</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.execute_compliant_interpolation">execute_compliant_interpolation</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.execute_interpolation">execute_interpolation</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.converge_to_pos">converge_to_pos</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.scan_motor_ids">scan_motor_ids</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.send_command">send_command</a>
                        </li>
                        <li>
                                <a class="function" href="#DynamixelPort.get_motor_value">get_motor_value</a>
                        </li>
                </ul>

            </li>
    </ul>



        <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
            built with <span class="visually-hidden">pdoc</span><img
                alt="pdoc logo"
                src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
        </a>
</div>
    </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
dynamixel_port    </h1>

                        <div class="docstring"><p>This file contains a Python class that provdes easy functionality for connecting to Dynamixel XL330 motors and for controlling them.
Please see test_dynamixel_port.py for a minimal working example of how to use this class.</p>

<p>In case you have any doubts or questions, please send an email to Steffen Puhlmann (spuhlmann@bht-berlin.de),
or even better: post your question on Moodle.</p>
</div>

                        <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: utf-8 -*-</span>


<span class="sd">&#39;&#39;&#39;</span>
<span class="sd">This file contains a Python class that provdes easy functionality for connecting to Dynamixel XL330 motors and for controlling them.</span>
<span class="sd">Please see test_dynamixel_port.py for a minimal working example of how to use this class.</span>

<span class="sd">In case you have any doubts or questions, please send an email to Steffen Puhlmann (spuhlmann@bht-berlin.de),</span>
<span class="sd">or even better: post your question on Moodle.</span>
<span class="sd">&#39;&#39;&#39;</span>



<span class="kn">from</span> <span class="nn">dynamixel_sdk</span> <span class="kn">import</span> <span class="o">*</span>               <span class="c1"># Dynamixel Python API</span>
<span class="kn">from</span> <span class="nn">dynamixel_xl330_conf</span> <span class="kn">import</span> <span class="o">*</span>        <span class="c1"># Memory addresses of Dynamixel motor control table</span>
<span class="kn">from</span> <span class="nn">linear_interpolation</span> <span class="kn">import</span> <span class="o">*</span>        <span class="c1"># Custom library for linearly interpolating between motor positions</span>
<span class="kn">import</span> <span class="nn">time</span>                               <span class="c1"># Access current time</span>


<span class="c1"># Specify some sonstants for setting the control modes</span>
<span class="n">CURRENT_CONTROL_MODE</span>            <span class="o">=</span> <span class="mi">0</span>
<span class="n">VELOCITY_CONTROL_MODE</span>           <span class="o">=</span> <span class="mi">1</span>
<span class="n">POSITION_CONTROL_MODE</span>           <span class="o">=</span> <span class="mi">3</span>
<span class="n">EXTENDED_POSITION_CONTROL_MODE</span>  <span class="o">=</span> <span class="mi">4</span>
<span class="n">CURRENT_POSITION_CONTROL_MODE</span>   <span class="o">=</span> <span class="mi">5</span>
<span class="n">PWM_CONTROL_MODE</span>                <span class="o">=</span> <span class="mi">16</span>




<span class="k">class</span> <span class="nc">DynamixelPort</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Provdes easy functionality for connecting to Dynamixel XL330 motors and for controlling them.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initializes a DynamixelPort Object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span>   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">establish_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_name</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="n">BAUDRATE</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Establishes a Serial (i.e. USB) connection to the U2D2 device,</span>
<span class="sd">        enabling communication to multiple Dynamixel motors</span>

<span class="sd">        :param device_name:         USB connection name (e.g. &quot;/dev/cu.usbserial-FT5WIPF3&quot; for a MAC USB device)</span>
<span class="sd">        :param baudrate:            Number of self-contained digital information packages per second</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Initialize PortHandler instance</span>
        <span class="c1"># Set the port path</span>
        <span class="c1"># Get methods and members of PortHandlerLinux or PortHandlerWindows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span> <span class="o">=</span> <span class="n">PortHandler</span><span class="p">(</span><span class="n">device_name</span><span class="p">)</span>

        <span class="c1"># Initialize PacketHandler instance</span>
        <span class="c1"># Set the protocol version</span>
        <span class="c1"># Get methods and members of Protocol1PacketHandler or Protocol2PacketHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="n">PacketHandler</span><span class="p">(</span><span class="n">PROTOCOL_VERSION</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_baudrate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Disconnects from U2D2 device, if connection has been previously established.</span>
<span class="sd">        Properly disconnecting from the device after use is highliy recommended to make sure that repeatededly connecting works reliably.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">closePort</span><span class="p">()</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_baudrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baudrate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the number of self-contained digital information packages to be transmitted per second.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">setBaudRate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_current</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Enables Dynamixel motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param enabled:     Enables motors if true, disables motors if false</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">TORQUE_ENABLE</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="n">TORQUE_DISABLE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>

        <span class="c1"># limit current</span>
        <span class="k">if</span> <span class="n">max_current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_MAXIMUM_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">max_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_MAXIMUM_CURRENT</span><span class="p">)</span>
    <span class="c1"># ---    </span>


    <span class="k">def</span> <span class="nf">set_operating_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Dynamixel motors can be controlled (or operated) in different ways (see the list below).</span>
<span class="sd">        This methods tells the Dynamixel motors whose IDs are element of ids to be controlled via a specific operating mode.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param mode:        Either a single control mode or a list of control modes. </span>
<span class="sd">                            In case of list, control mode at index i in mode will be assigned to motor with ID at index i in ids.</span>

<span class="sd">        The parameter mode needs to have one of the following values:</span>
<span class="sd">        * 0 - **Current Control Mode**: Only controls current (torque) regardless of speed and position. This mode is ideal for a gripper or a system that only uses current(torque) control or a system that has additional velocity/position controllers.</span>
<span class="sd">        * 1 - **Velocity Control Mode**: This mode controls velocity. This mode is identical to the Wheel Mode(endless) from existing DYNAMIXEL. This mode is ideal for wheel-type robots.</span>
<span class="sd">        * 3 - **Position Control Mode** (Default): This mode controls position. This mode is identical to the Joint Mode from existing DYNAMIXEL. Operating position range is limited by the Max Position Limit(48) and the Min Position Limit(52). This mode is ideal for articulated robots that each joint rotates less than 360 degrees.</span>
<span class="sd">        * 4 - **Extended Position Control Mode** (Multi-turn): This mode controls position. This mode is identical to the Multi-turn Position Control from existing DYNAMIXEL. 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for multi-turn wrists or conveyer systems or a system that requires an additional reduction gear. Note that Max Position Limit(48), Min Position Limit(52) are not used on Extended Position Control Mode.</span>
<span class="sd">        * 5 - **Current-based Position Control Mode**: This mode controls both position and current(torque). Up to 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for a system that requires both position and current control such as articulated robots or grippers.</span>
<span class="sd">        * 16 - **PWM Control Mode (Voltage Control Mode)**: This mode directly controls PWM output. (Voltage Control Mode)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_OPERATING_MODE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_OPERATING_MODE</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_pos</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal positions (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Position Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal position or a list of goal positions. </span>
<span class="sd">                            In case of list, goal position at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_POSITION</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_pos</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_POSITION</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_vel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal velocities (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Velocity Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal velocity or a list of goal velocities. </span>
<span class="sd">                            In case of list, goal velocity at index i in goal_vel will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_VELOCITY</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_vel</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_VELOCITY</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal currents (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Current Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal current or a list of goal currents. </span>
<span class="sd">                            In case of list, goal current at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_CURRENT</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns whether torques of motors specified in ids are enabled.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>
        <span class="n">enabled</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">TORQUE_ENABLE</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">message</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">enabled</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">multi_turn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current position of motors specified in ids</span>

<span class="sd">        :param ids:           Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param multi_turn:    If set to True, it will return motor position between -256 and +256 turns. Hence, the values 0 and 4095 (representing the min. and max. values within a single turn) will be exceeded.</span>
<span class="sd">                              If set to True, it will return the motor position between 0 and 4095.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_POSITION</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_POSITION</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multi_turn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">%</span> <span class="mi">4096</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current velocity of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VELOCITY</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VELOCITY</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vel</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current current of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_CURRENT</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_CURRENT</span><span class="p">,</span>
                                       <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current input voltage of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">voltage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VOLTAGE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VOLTAGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">voltage</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">execute_compliant_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor mode is changed to CURRENT_POSITION_CONTROL_MODE and the maximally allowed current is set to &lt;current&gt;.</span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param current:     Maxiumum current. The lower, the more compliant (~weaker) and the higher, the stiffer (~stronger) the motors.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_torque_enabled</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_interpolation</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">reset_duration</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">execute_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor operation mode is not changed by this function. </span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># create object providing functionality for linear interpolation</span>
        <span class="c1"># based on the provided keyframes and time durations</span>
        <span class="n">lin</span> <span class="o">=</span> <span class="n">LinearInterpolation</span><span class="p">(</span><span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>

        <span class="c1"># check for errors in parameters:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lin</span><span class="o">.</span><span class="n">n_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: There must be the same number of motor IDs as the number of keyframe dimensions!&#39;</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># before starting the interpolation, we add a temporary keyframe in order to move </span>
            <span class="c1"># from the current motor position to the first keyframe in &lt;reset_duration&gt; seconds.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">appfront</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">reset_duration</span><span class="p">)</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">lin</span><span class="o">.</span><span class="n">total_duration</span><span class="p">:</span>
            <span class="n">interpolated_motor_pos</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">get_values_for_time</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">interpolated_motor_pos</span><span class="p">)</span>
        <span class="c1"># --</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># after we are done, we delete the temporary keyframe we added above which moved the motors</span>
            <span class="c1"># to the first keyframe of the interpolation.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">converge_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">target_pos</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Moves motors a step towards desired motor positions.</span>
<span class="sd">        Internally, this is a P-Controller.  </span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :target_pos:        Desired motor positions. This vector needs to have the same number of elements as ids.</span>
<span class="sd">        :gain:              Scalar value that is multiplied to the error between desired and actual motor position (should be smaller than 1.0)</span>
<span class="sd">        :current:           The maximum current (i.e., torque) applied by the motors. Can be a scalar value or a vector.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="n">curr_pos</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">delta_pos</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">curr_pos</span> <span class="o">-</span> <span class="n">target_pos</span><span class="p">)</span>
        <span class="n">goal_pos</span>  <span class="o">=</span> <span class="n">curr_pos</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delta_pos</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">goal_pos</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">scan_motor_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of IDs of connected motors.</span>

<span class="sd">        param candidates: [optional] List of IDs to check. If not provided, this method will scan IDs from 0 to 255</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">found_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">ADDR_TORQUE_ENABLE</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dxl_error</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dxl_comm_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">found_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">found_ids</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends a control command to a dynamixel motor by setting one of the motor&#39;s variables that is encoeded by nbytes many bytes at a certain address to a certain value.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:     Memory address for storing command value in Dynamixel motor.</span>
<span class="sd">        :param value:       Either a single value or a list of values. </span>
<span class="sd">                            In case of list, value at index i in values will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        :param n_bytes:     Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># make sure motor_ids is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ids</span><span class="p">]</span>

        <span class="c1"># make sure values is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">value</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># --</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_motor_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">two_comp_thres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns motor command values stored at specified memory addresses in motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:                 Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:             Memory address for reading out command value in each Dynamixel motor.</span>
<span class="sd">        :param n_bytes:             Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        :param two_comp_thres:      If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        :param two_comp_sub:        If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>

            <span class="c1"># error notification</span>
            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">two_comp_thres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dxl_value</span> <span class="o">&gt;</span> <span class="n">two_comp_thres</span><span class="p">:</span> <span class="n">dxl_value</span><span class="o">-=</span> <span class="n">two_comp_sub</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dxl_value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">values</span>
    <span class="c1"># ---</span>
</pre></div>

        </details>

            </section>
                <section id="DynamixelPort">
                                <div class="attr class">
        <a class="headerlink" href="#DynamixelPort">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DynamixelPort</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DynamixelPort</span><span class="p">:</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Provdes easy functionality for connecting to Dynamixel XL330 motors and for controlling them.</span>
<span class="sd">    &#39;&#39;&#39;</span>


    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initializes a DynamixelPort Object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span>   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">establish_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_name</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="n">BAUDRATE</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Establishes a Serial (i.e. USB) connection to the U2D2 device,</span>
<span class="sd">        enabling communication to multiple Dynamixel motors</span>

<span class="sd">        :param device_name:         USB connection name (e.g. &quot;/dev/cu.usbserial-FT5WIPF3&quot; for a MAC USB device)</span>
<span class="sd">        :param baudrate:            Number of self-contained digital information packages per second</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Initialize PortHandler instance</span>
        <span class="c1"># Set the port path</span>
        <span class="c1"># Get methods and members of PortHandlerLinux or PortHandlerWindows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span> <span class="o">=</span> <span class="n">PortHandler</span><span class="p">(</span><span class="n">device_name</span><span class="p">)</span>

        <span class="c1"># Initialize PacketHandler instance</span>
        <span class="c1"># Set the protocol version</span>
        <span class="c1"># Get methods and members of Protocol1PacketHandler or Protocol2PacketHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="n">PacketHandler</span><span class="p">(</span><span class="n">PROTOCOL_VERSION</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_baudrate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Disconnects from U2D2 device, if connection has been previously established.</span>
<span class="sd">        Properly disconnecting from the device after use is highliy recommended to make sure that repeatededly connecting works reliably.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">closePort</span><span class="p">()</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_baudrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baudrate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the number of self-contained digital information packages to be transmitted per second.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">setBaudRate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_current</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Enables Dynamixel motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param enabled:     Enables motors if true, disables motors if false</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">TORQUE_ENABLE</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="n">TORQUE_DISABLE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>

        <span class="c1"># limit current</span>
        <span class="k">if</span> <span class="n">max_current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_MAXIMUM_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">max_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_MAXIMUM_CURRENT</span><span class="p">)</span>
    <span class="c1"># ---    </span>


    <span class="k">def</span> <span class="nf">set_operating_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Dynamixel motors can be controlled (or operated) in different ways (see the list below).</span>
<span class="sd">        This methods tells the Dynamixel motors whose IDs are element of ids to be controlled via a specific operating mode.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param mode:        Either a single control mode or a list of control modes. </span>
<span class="sd">                            In case of list, control mode at index i in mode will be assigned to motor with ID at index i in ids.</span>

<span class="sd">        The parameter mode needs to have one of the following values:</span>
<span class="sd">        * 0 - **Current Control Mode**: Only controls current (torque) regardless of speed and position. This mode is ideal for a gripper or a system that only uses current(torque) control or a system that has additional velocity/position controllers.</span>
<span class="sd">        * 1 - **Velocity Control Mode**: This mode controls velocity. This mode is identical to the Wheel Mode(endless) from existing DYNAMIXEL. This mode is ideal for wheel-type robots.</span>
<span class="sd">        * 3 - **Position Control Mode** (Default): This mode controls position. This mode is identical to the Joint Mode from existing DYNAMIXEL. Operating position range is limited by the Max Position Limit(48) and the Min Position Limit(52). This mode is ideal for articulated robots that each joint rotates less than 360 degrees.</span>
<span class="sd">        * 4 - **Extended Position Control Mode** (Multi-turn): This mode controls position. This mode is identical to the Multi-turn Position Control from existing DYNAMIXEL. 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for multi-turn wrists or conveyer systems or a system that requires an additional reduction gear. Note that Max Position Limit(48), Min Position Limit(52) are not used on Extended Position Control Mode.</span>
<span class="sd">        * 5 - **Current-based Position Control Mode**: This mode controls both position and current(torque). Up to 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for a system that requires both position and current control such as articulated robots or grippers.</span>
<span class="sd">        * 16 - **PWM Control Mode (Voltage Control Mode)**: This mode directly controls PWM output. (Voltage Control Mode)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_OPERATING_MODE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_OPERATING_MODE</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_pos</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal positions (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Position Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal position or a list of goal positions. </span>
<span class="sd">                            In case of list, goal position at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_POSITION</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_pos</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_POSITION</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_vel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal velocities (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Velocity Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal velocity or a list of goal velocities. </span>
<span class="sd">                            In case of list, goal velocity at index i in goal_vel will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_VELOCITY</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_vel</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_VELOCITY</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">set_goal_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal currents (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Current Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal current or a list of goal currents. </span>
<span class="sd">                            In case of list, goal current at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_CURRENT</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns whether torques of motors specified in ids are enabled.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>
        <span class="n">enabled</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">TORQUE_ENABLE</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">message</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">enabled</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">multi_turn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current position of motors specified in ids</span>

<span class="sd">        :param ids:           Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param multi_turn:    If set to True, it will return motor position between -256 and +256 turns. Hence, the values 0 and 4095 (representing the min. and max. values within a single turn) will be exceeded.</span>
<span class="sd">                              If set to True, it will return the motor position between 0 and 4095.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_POSITION</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_POSITION</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multi_turn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">%</span> <span class="mi">4096</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current velocity of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VELOCITY</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VELOCITY</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vel</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current current of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_CURRENT</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_CURRENT</span><span class="p">,</span>
                                       <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current input voltage of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">voltage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VOLTAGE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VOLTAGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">voltage</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">execute_compliant_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor mode is changed to CURRENT_POSITION_CONTROL_MODE and the maximally allowed current is set to &lt;current&gt;.</span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param current:     Maxiumum current. The lower, the more compliant (~weaker) and the higher, the stiffer (~stronger) the motors.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_torque_enabled</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_interpolation</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">reset_duration</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">execute_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor operation mode is not changed by this function. </span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># create object providing functionality for linear interpolation</span>
        <span class="c1"># based on the provided keyframes and time durations</span>
        <span class="n">lin</span> <span class="o">=</span> <span class="n">LinearInterpolation</span><span class="p">(</span><span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>

        <span class="c1"># check for errors in parameters:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lin</span><span class="o">.</span><span class="n">n_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: There must be the same number of motor IDs as the number of keyframe dimensions!&#39;</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># before starting the interpolation, we add a temporary keyframe in order to move </span>
            <span class="c1"># from the current motor position to the first keyframe in &lt;reset_duration&gt; seconds.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">appfront</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">reset_duration</span><span class="p">)</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">lin</span><span class="o">.</span><span class="n">total_duration</span><span class="p">:</span>
            <span class="n">interpolated_motor_pos</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">get_values_for_time</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">interpolated_motor_pos</span><span class="p">)</span>
        <span class="c1"># --</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># after we are done, we delete the temporary keyframe we added above which moved the motors</span>
            <span class="c1"># to the first keyframe of the interpolation.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">converge_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">target_pos</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Moves motors a step towards desired motor positions.</span>
<span class="sd">        Internally, this is a P-Controller.  </span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :target_pos:        Desired motor positions. This vector needs to have the same number of elements as ids.</span>
<span class="sd">        :gain:              Scalar value that is multiplied to the error between desired and actual motor position (should be smaller than 1.0)</span>
<span class="sd">        :current:           The maximum current (i.e., torque) applied by the motors. Can be a scalar value or a vector.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="n">curr_pos</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">delta_pos</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">curr_pos</span> <span class="o">-</span> <span class="n">target_pos</span><span class="p">)</span>
        <span class="n">goal_pos</span>  <span class="o">=</span> <span class="n">curr_pos</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delta_pos</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">goal_pos</span><span class="p">)</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">scan_motor_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of IDs of connected motors.</span>

<span class="sd">        param candidates: [optional] List of IDs to check. If not provided, this method will scan IDs from 0 to 255</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">found_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">ADDR_TORQUE_ENABLE</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dxl_error</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dxl_comm_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">found_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">found_ids</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends a control command to a dynamixel motor by setting one of the motor&#39;s variables that is encoeded by nbytes many bytes at a certain address to a certain value.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:     Memory address for storing command value in Dynamixel motor.</span>
<span class="sd">        :param value:       Either a single value or a list of values. </span>
<span class="sd">                            In case of list, value at index i in values will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        :param n_bytes:     Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># make sure motor_ids is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ids</span><span class="p">]</span>

        <span class="c1"># make sure values is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">value</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># --</span>
    <span class="c1"># ---</span>


    <span class="k">def</span> <span class="nf">get_motor_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">two_comp_thres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns motor command values stored at specified memory addresses in motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:                 Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:             Memory address for reading out command value in each Dynamixel motor.</span>
<span class="sd">        :param n_bytes:             Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        :param two_comp_thres:      If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        :param two_comp_sub:        If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>

            <span class="c1"># error notification</span>
            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">two_comp_thres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dxl_value</span> <span class="o">&gt;</span> <span class="n">two_comp_thres</span><span class="p">:</span> <span class="n">dxl_value</span><span class="o">-=</span> <span class="n">two_comp_sub</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dxl_value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">values</span>
    <span class="c1"># ---</span>
</pre></div>

        </details>

            <div class="docstring"><p>Provdes easy functionality for connecting to Dynamixel XL330 motors and for controlling them.</p>
</div>


                            <div id="DynamixelPort.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DynamixelPort</span><span class="signature">()</span>
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Initializes a DynamixelPort Object.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span>   <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="kc">None</span>
</pre></div>

        </details>

            <div class="docstring"><p>Initializes a DynamixelPort Object.</p>
</div>


                            </div>
                            <div id="DynamixelPort.establish_connection" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.establish_connection">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">establish_connection</span><span class="signature">(self, device_name, baudrate=57600)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">establish_connection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">device_name</span><span class="p">,</span> <span class="n">baudrate</span><span class="o">=</span><span class="n">BAUDRATE</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Establishes a Serial (i.e. USB) connection to the U2D2 device,</span>
<span class="sd">        enabling communication to multiple Dynamixel motors</span>

<span class="sd">        :param device_name:         USB connection name (e.g. &quot;/dev/cu.usbserial-FT5WIPF3&quot; for a MAC USB device)</span>
<span class="sd">        :param baudrate:            Number of self-contained digital information packages per second</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># Initialize PortHandler instance</span>
        <span class="c1"># Set the port path</span>
        <span class="c1"># Get methods and members of PortHandlerLinux or PortHandlerWindows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span> <span class="o">=</span> <span class="n">PortHandler</span><span class="p">(</span><span class="n">device_name</span><span class="p">)</span>

        <span class="c1"># Initialize PacketHandler instance</span>
        <span class="c1"># Set the protocol version</span>
        <span class="c1"># Get methods and members of Protocol1PacketHandler or Protocol2PacketHandler</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span> <span class="o">=</span> <span class="n">PacketHandler</span><span class="p">(</span><span class="n">PROTOCOL_VERSION</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_baudrate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Establishes a Serial (i.e. USB) connection to the U2D2 device,
enabling communication to multiple Dynamixel motors</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>device_name</strong>:          USB connection name (e.g. "/dev/cu.usbserial-FT5WIPF3" for a MAC USB device)</li>
<li><strong>baudrate</strong>:             Number of self-contained digital information packages per second</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.disconnect" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.disconnect">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">disconnect</span><span class="signature">(self)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">disconnect</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Disconnects from U2D2 device, if connection has been previously established.</span>
<span class="sd">        Properly disconnecting from the device after use is highliy recommended to make sure that repeatededly connecting works reliably.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">closePort</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Disconnects from U2D2 device, if connection has been previously established.
Properly disconnecting from the device after use is highliy recommended to make sure that repeatededly connecting works reliably.</p>
</div>


                            </div>
                            <div id="DynamixelPort.set_baudrate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_baudrate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_baudrate</span><span class="signature">(self, baudrate) -&gt; None</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_baudrate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">baudrate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sets the number of self-contained digital information packages to be transmitted per second.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="o">.</span><span class="n">setBaudRate</span><span class="p">(</span><span class="n">baudrate</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the number of self-contained digital information packages to be transmitted per second.</p>
</div>


                            </div>
                            <div id="DynamixelPort.set_torque_enabled" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_torque_enabled">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_torque_enabled</span><span class="signature">(self, ids, enabled=True, max_current=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">enabled</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">max_current</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Enables Dynamixel motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param enabled:     Enables motors if true, disables motors if false</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">TORQUE_ENABLE</span> <span class="k">if</span> <span class="n">enabled</span> <span class="k">else</span> <span class="n">TORQUE_DISABLE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>

        <span class="c1"># limit current</span>
        <span class="k">if</span> <span class="n">max_current</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_MAXIMUM_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">max_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_MAXIMUM_CURRENT</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Enables Dynamixel motors whose IDs are element of ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>enabled</strong>:      Enables motors if true, disables motors if false</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.set_operating_mode" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_operating_mode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_operating_mode</span><span class="signature">(self, ids, mode)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_operating_mode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">mode</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Dynamixel motors can be controlled (or operated) in different ways (see the list below).</span>
<span class="sd">        This methods tells the Dynamixel motors whose IDs are element of ids to be controlled via a specific operating mode.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param mode:        Either a single control mode or a list of control modes. </span>
<span class="sd">                            In case of list, control mode at index i in mode will be assigned to motor with ID at index i in ids.</span>

<span class="sd">        The parameter mode needs to have one of the following values:</span>
<span class="sd">        * 0 - **Current Control Mode**: Only controls current (torque) regardless of speed and position. This mode is ideal for a gripper or a system that only uses current(torque) control or a system that has additional velocity/position controllers.</span>
<span class="sd">        * 1 - **Velocity Control Mode**: This mode controls velocity. This mode is identical to the Wheel Mode(endless) from existing DYNAMIXEL. This mode is ideal for wheel-type robots.</span>
<span class="sd">        * 3 - **Position Control Mode** (Default): This mode controls position. This mode is identical to the Joint Mode from existing DYNAMIXEL. Operating position range is limited by the Max Position Limit(48) and the Min Position Limit(52). This mode is ideal for articulated robots that each joint rotates less than 360 degrees.</span>
<span class="sd">        * 4 - **Extended Position Control Mode** (Multi-turn): This mode controls position. This mode is identical to the Multi-turn Position Control from existing DYNAMIXEL. 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for multi-turn wrists or conveyer systems or a system that requires an additional reduction gear. Note that Max Position Limit(48), Min Position Limit(52) are not used on Extended Position Control Mode.</span>
<span class="sd">        * 5 - **Current-based Position Control Mode**: This mode controls both position and current(torque). Up to 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for a system that requires both position and current control such as articulated robots or grippers.</span>
<span class="sd">        * 16 - **PWM Control Mode (Voltage Control Mode)**: This mode directly controls PWM output. (Voltage Control Mode)</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_OPERATING_MODE</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_OPERATING_MODE</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Dynamixel motors can be controlled (or operated) in different ways (see the list below).
This methods tells the Dynamixel motors whose IDs are element of ids to be controlled via a specific operating mode.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>mode</strong>:         Either a single control mode or a list of control modes. 
                In case of list, control mode at index i in mode will be assigned to motor with ID at index i in ids.</li>
</ul>

<p>The parameter mode needs to have one of the following values:</p>

<ul>
<li>0 - <strong>Current Control Mode</strong>: Only controls current (torque) regardless of speed and position. This mode is ideal for a gripper or a system that only uses current(torque) control or a system that has additional velocity/position controllers.</li>
<li>1 - <strong>Velocity Control Mode</strong>: This mode controls velocity. This mode is identical to the Wheel Mode(endless) from existing DYNAMIXEL. This mode is ideal for wheel-type robots.</li>
<li>3 - <strong>Position Control Mode</strong> (Default): This mode controls position. This mode is identical to the Joint Mode from existing DYNAMIXEL. Operating position range is limited by the Max Position Limit(48) and the Min Position Limit(52). This mode is ideal for articulated robots that each joint rotates less than 360 degrees.</li>
<li>4 - <strong>Extended Position Control Mode</strong> (Multi-turn): This mode controls position. This mode is identical to the Multi-turn Position Control from existing DYNAMIXEL. 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for multi-turn wrists or conveyer systems or a system that requires an additional reduction gear. Note that Max Position Limit(48), Min Position Limit(52) are not used on Extended Position Control Mode.</li>
<li>5 - <strong>Current-based Position Control Mode</strong>: This mode controls both position and current(torque). Up to 512 turns are supported(-256[rev] ~ 256[rev]). This mode is ideal for a system that requires both position and current control such as articulated robots or grippers.</li>
<li>16 - <strong>PWM Control Mode (Voltage Control Mode)</strong>: This mode directly controls PWM output. (Voltage Control Mode)</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.set_goal_pos" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_goal_pos">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_goal_pos</span><span class="signature">(self, ids, goal_pos)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_goal_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_pos</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal positions (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Position Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal position or a list of goal positions. </span>
<span class="sd">                            In case of list, goal position at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_POSITION</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_pos</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_POSITION</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sends goal positions (can be scalar or list) to motors specified in ids.
For this to work, the motors need be in Position Control Mode or in Current-based Position Control Mode.
(For further information, see method set_operating_mode)</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>goal_pos</strong>:     Either a single goal position or a list of goal positions. 
                In case of list, goal position at index i in goal_pos will be assigned to motor with ID at index i in ids.</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.set_goal_vel" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_goal_vel">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_goal_vel</span><span class="signature">(self, ids, goal_vel)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_goal_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_vel</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal velocities (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Velocity Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal velocity or a list of goal velocities. </span>
<span class="sd">                            In case of list, goal velocity at index i in goal_vel will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_VELOCITY</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_vel</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_VELOCITY</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sends goal velocities (can be scalar or list) to motors specified in ids.
For this to work, the motors need be in Velocity Control Mode.
(For further information, see method set_operating_mode)</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>goal_pos</strong>:     Either a single goal velocity or a list of goal velocities. 
                In case of list, goal velocity at index i in goal_vel will be assigned to motor with ID at index i in ids.</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.set_goal_current" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.set_goal_current">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_goal_current</span><span class="signature">(self, ids, goal_current)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_goal_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">goal_current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends goal currents (can be scalar or list) to motors specified in ids.</span>
<span class="sd">        For this to work, the motors need be in Current Control Mode or in Current-based Position Control Mode.</span>
<span class="sd">        (For further information, see method set_operating_mode)</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param goal_pos:    Either a single goal current or a list of goal currents. </span>
<span class="sd">                            In case of list, goal current at index i in goal_pos will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">send_command</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_GOAL_CURRENT</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">goal_current</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_GOAL_CURRENT</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sends goal currents (can be scalar or list) to motors specified in ids.
For this to work, the motors need be in Current Control Mode or in Current-based Position Control Mode.
(For further information, see method set_operating_mode)</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>goal_pos</strong>:     Either a single goal current or a list of goal currents. 
                In case of list, goal current at index i in goal_pos will be assigned to motor with ID at index i in ids.</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_torque_enabled" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_torque_enabled">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_torque_enabled</span><span class="signature">(self, ids)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_torque_enabled</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns whether torques of motors specified in ids are enabled.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">message</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_TORQUE_ENABLE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_TORQUE_ENABLE</span><span class="p">)</span>
        <span class="n">enabled</span> <span class="o">=</span> <span class="p">[</span><span class="kc">True</span> <span class="k">if</span> <span class="n">msg</span> <span class="o">==</span> <span class="n">TORQUE_ENABLE</span> <span class="k">else</span> <span class="kc">False</span> <span class="k">for</span> <span class="n">msg</span> <span class="ow">in</span> <span class="n">message</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">enabled</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether torques of motors specified in ids are enabled.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_pos" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_pos">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_pos</span><span class="signature">(self, ids, multi_turn=False)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">multi_turn</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current position of motors specified in ids</span>

<span class="sd">        :param ids:           Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param multi_turn:    If set to True, it will return motor position between -256 and +256 turns. Hence, the values 0 and 4095 (representing the min. and max. values within a single turn) will be exceeded.</span>
<span class="sd">                              If set to True, it will return the motor position between 0 and 4095.</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="n">pos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_POSITION</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_POSITION</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">multi_turn</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pos</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">p</span> <span class="o">%</span> <span class="mi">4096</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">pos</span><span class="p">]</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns current position of motors specified in ids</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:            Either an array of motor IDs, or a single motor ID</li>
<li><strong>multi_turn</strong>:     If set to True, it will return motor position between -256 and +256 turns. Hence, the values 0 and 4095 (representing the min. and max. values within a single turn) will be exceeded.
                  If set to True, it will return the motor position between 0 and 4095.</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_vel" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_vel">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_vel</span><span class="signature">(self, ids)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_vel</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current velocity of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">vel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VELOCITY</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VELOCITY</span><span class="p">,</span> 
                                   <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fffffff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">4294967296</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vel</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns current velocity of motors specified in ids</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_current" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_current">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_current</span><span class="signature">(self, ids)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_current</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current current of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">current</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_CURRENT</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_CURRENT</span><span class="p">,</span>
                                       <span class="n">two_comp_thres</span><span class="o">=</span><span class="mh">0x7fff</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="mi">65536</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">current</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns current current of motors specified in ids</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_voltage" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_voltage">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_voltage</span><span class="signature">(self, ids)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_voltage</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns current input voltage of motors specified in ids</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">voltage</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_motor_value</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="o">=</span><span class="n">ADDR_PRESENT_VOLTAGE</span><span class="p">,</span> <span class="n">nbytes</span><span class="o">=</span><span class="n">NBYTES_PRESENT_VOLTAGE</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">voltage</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns current input voltage of motors specified in ids</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.execute_compliant_interpolation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.execute_compliant_interpolation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">execute_compliant_interpolation</span><span class="signature">(
    self,
    ids,
    keyframes,
    durations,
    current=200,
    reset=False,
    reset_duration=3.0
)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">execute_compliant_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">current</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor mode is changed to CURRENT_POSITION_CONTROL_MODE and the maximally allowed current is set to &lt;current&gt;.</span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param current:     Maxiumum current. The lower, the more compliant (~weaker) and the higher, the stiffer (~stronger) the motors.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_torque_enabled</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">execute_interpolation</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="p">,</span> <span class="n">reset_duration</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.
The motor mode is changed to CURRENT_POSITION_CONTROL_MODE and the maximally allowed current is set to <current>.
Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.
If <reset> is True, the motors will first move to the very first keyframe of the interpolation within <reset_duration> seconds.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>keyframes</strong>:    List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</li>
<li><strong>durations</strong>:    Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</li>
<li><strong>current</strong>:      Maxiumum current. The lower, the more compliant (~weaker) and the higher, the stiffer (~stronger) the motors.</li>
<li><strong>reset</strong>:        If True, motors move to first keyframe in interpolation within <reset_duration> seconds.</li>
<li><strong>reset_time</strong>:   Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.execute_interpolation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.execute_interpolation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">execute_interpolation</span><span class="signature">(self, ids, keyframes, durations, reset=False, reset_duration=3.0)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">execute_interpolation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">,</span> <span class="n">reset</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reset_duration</span><span class="o">=</span><span class="mf">3.</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.</span>
<span class="sd">        The motor operation mode is not changed by this function. </span>
<span class="sd">        Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.</span>
<span class="sd">        If &lt;reset&gt; is True, the motors will first move to the very first keyframe of the interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        </span>
<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param keyframes:   List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</span>
<span class="sd">        :param durations:   Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</span>
<span class="sd">        :param reset:       If True, motors move to first keyframe in interpolation within &lt;reset_duration&gt; seconds.</span>
<span class="sd">        :param reset_time:  Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</span>
<span class="sd">        &#39;&#39;&#39;</span>

        <span class="c1"># create object providing functionality for linear interpolation</span>
        <span class="c1"># based on the provided keyframes and time durations</span>
        <span class="n">lin</span> <span class="o">=</span> <span class="n">LinearInterpolation</span><span class="p">(</span><span class="n">keyframes</span><span class="p">,</span> <span class="n">durations</span><span class="p">)</span>

        <span class="c1"># check for errors in parameters:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">!=</span> <span class="n">lin</span><span class="o">.</span><span class="n">n_dim</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;ERROR: There must be the same number of motor IDs as the number of keyframe dimensions!&#39;</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># before starting the interpolation, we add a temporary keyframe in order to move </span>
            <span class="c1"># from the current motor position to the first keyframe in &lt;reset_duration&gt; seconds.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">appfront</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">),</span> <span class="n">reset_duration</span><span class="p">)</span>

        <span class="n">start_time</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="k">while</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span> <span class="o">&lt;</span> <span class="n">lin</span><span class="o">.</span><span class="n">total_duration</span><span class="p">:</span>
            <span class="n">interpolated_motor_pos</span> <span class="o">=</span> <span class="n">lin</span><span class="o">.</span><span class="n">get_values_for_time</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span> <span class="o">-</span> <span class="n">start_time</span><span class="p">)</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">interpolated_motor_pos</span><span class="p">)</span>
        <span class="c1"># --</span>

        <span class="k">if</span> <span class="n">reset</span><span class="p">:</span>
            <span class="c1"># after we are done, we delete the temporary keyframe we added above which moved the motors</span>
            <span class="c1"># to the first keyframe of the interpolation.</span>
            <span class="n">lin</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Executes a linear transformation between keyframes and executes the motors specified in ids accordingly.
The motor operation mode is not changed by this function. 
Here, the first keyframe dimension refers to the first motor position, the second keyframe dimension for the second motor, and so on.
If <reset> is True, the motors will first move to the very first keyframe of the interpolation within <reset_duration> seconds.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>keyframes</strong>:    List of keyframes. A keyframe is a vector and contains motor positions. All keyframes must have the same number of dimensions.</li>
<li><strong>durations</strong>:    Stores the times (in seconds) it takes to transition between keyframes. There must be exactly n_keyframes-1 time durations.</li>
<li><strong>reset</strong>:        If True, motors move to first keyframe in interpolation within <reset_duration> seconds.</li>
<li><strong>reset_time</strong>:   Time (in seconds) it takes for the motors to reach the first keyframe of the interpolation</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.converge_to_pos" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.converge_to_pos">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">converge_to_pos</span><span class="signature">(self, ids, target_pos, gain, current)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">converge_to_pos</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">target_pos</span><span class="p">,</span> <span class="n">gain</span><span class="p">,</span> <span class="n">current</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Moves motors a step towards desired motor positions.</span>
<span class="sd">        Internally, this is a P-Controller.  </span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :target_pos:        Desired motor positions. This vector needs to have the same number of elements as ids.</span>
<span class="sd">        :gain:              Scalar value that is multiplied to the error between desired and actual motor position (should be smaller than 1.0)</span>
<span class="sd">        :current:           The maximum current (i.e., torque) applied by the motors. Can be a scalar value or a vector.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_operating_mode</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">CURRENT_POSITION_CONTROL_MODE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_current</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">current</span><span class="p">)</span>
        <span class="n">curr_pos</span>  <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_pos</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>
        <span class="n">delta_pos</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">*</span> <span class="n">gain</span> <span class="o">*</span> <span class="p">(</span><span class="n">curr_pos</span> <span class="o">-</span> <span class="n">target_pos</span><span class="p">)</span>
        <span class="n">goal_pos</span>  <span class="o">=</span> <span class="n">curr_pos</span> <span class="o">+</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">delta_pos</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_goal_pos</span><span class="p">(</span><span class="n">goal_pos</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Moves motors a step towards desired motor positions.
Internally, this is a P-Controller.  </p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID
:target_pos:        Desired motor positions. This vector needs to have the same number of elements as ids.
:gain:              Scalar value that is multiplied to the error between desired and actual motor position (should be smaller than 1.0)
:current:           The maximum current (i.e., torque) applied by the motors. Can be a scalar value or a vector.</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.scan_motor_ids" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.scan_motor_ids">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">scan_motor_ids</span><span class="signature">(self, candidates=range(0, 256))</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">scan_motor_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">candidates</span><span class="o">=</span><span class="nb">range</span><span class="p">(</span><span class="mi">256</span><span class="p">)):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns a list of IDs of connected motors.</span>

<span class="sd">        param candidates: [optional] List of IDs to check. If not provided, this method will scan IDs from 0 to 255</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">found_ids</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">candidates</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">ADDR_TORQUE_ENABLE</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">dxl_error</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">dxl_comm_result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">found_ids</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">id</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">found_ids</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a list of IDs of connected motors.</p>

<p>param candidates: [optional] List of IDs to check. If not provided, this method will scan IDs from 0 to 255</p>
</div>


                            </div>
                            <div id="DynamixelPort.send_command" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.send_command">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">send_command</span><span class="signature">(self, ids, address, value, nbytes)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">send_command</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Sends a control command to a dynamixel motor by setting one of the motor&#39;s variables that is encoeded by nbytes many bytes at a certain address to a certain value.</span>

<span class="sd">        :param ids:         Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:     Memory address for storing command value in Dynamixel motor.</span>
<span class="sd">        :param value:       Either a single value or a list of values. </span>
<span class="sd">                            In case of list, value at index i in values will be assigned to motor with ID at index i in ids.</span>
<span class="sd">        :param n_bytes:     Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="c1"># make sure motor_ids is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">ids</span> <span class="o">=</span> <span class="p">[</span><span class="n">ids</span><span class="p">]</span>

        <span class="c1"># make sure values is some kind of list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span> <span class="n">value</span> <span class="o">=</span> <span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="p">(</span><span class="nb">id</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ids</span><span class="p">,</span> <span class="n">value</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">write4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># --</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sends a control command to a dynamixel motor by setting one of the motor's variables that is encoeded by nbytes many bytes at a certain address to a certain value.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:          Either an array of motor IDs, or a single motor ID</li>
<li><strong>address</strong>:      Memory address for storing command value in Dynamixel motor.</li>
<li><strong>value</strong>:        Either a single value or a list of values. 
                In case of list, value at index i in values will be assigned to motor with ID at index i in ids.</li>
<li><strong>n_bytes</strong>:      Number of bytes that encode the command value (either 1, 2, or 4).</li>
</ul>
</div>


                            </div>
                            <div id="DynamixelPort.get_motor_value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DynamixelPort.get_motor_value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">get_motor_value</span><span class="signature">(self, ids, address, nbytes, two_comp_thres=None, two_comp_sub=None)</span>:
    </div>

            <details>
            <summary>View Source</summary>
            <div class="pdoc-code codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">get_motor_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ids</span><span class="p">,</span> <span class="n">address</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">two_comp_thres</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">two_comp_sub</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">        Returns motor command values stored at specified memory addresses in motors whose IDs are element of ids.</span>

<span class="sd">        :param ids:                 Either an array of motor IDs, or a single motor ID</span>
<span class="sd">        :param address:             Memory address for reading out command value in each Dynamixel motor.</span>
<span class="sd">        :param n_bytes:             Number of bytes that encode the command value (either 1, 2, or 4).</span>
<span class="sd">        :param two_comp_thres:      If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        :param two_comp_sub:        If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</span>
<span class="sd">        &#39;&#39;&#39;</span>
        <span class="n">values</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read1ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read2ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">nbytes</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">dxl_value</span><span class="p">,</span> <span class="n">dxl_comm_result</span><span class="p">,</span> <span class="n">dxl_error</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">read4ByteTxRx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">port_handler</span><span class="p">,</span> <span class="nb">id</span><span class="p">,</span> <span class="n">address</span><span class="p">)</span>

            <span class="c1"># error notification</span>
            <span class="k">if</span> <span class="n">dxl_comm_result</span> <span class="o">!=</span> <span class="n">COMM_SUCCESS</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getTxRxResult</span><span class="p">(</span><span class="n">dxl_comm_result</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">dxl_error</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">packet_handler</span><span class="o">.</span><span class="n">getRxPacketError</span><span class="p">(</span><span class="n">dxl_error</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">two_comp_thres</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">dxl_value</span> <span class="o">&gt;</span> <span class="n">two_comp_thres</span><span class="p">:</span> <span class="n">dxl_value</span><span class="o">-=</span> <span class="n">two_comp_sub</span>

            <span class="n">values</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dxl_value</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">values</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns motor command values stored at specified memory addresses in motors whose IDs are element of ids.</p>

<h6 id="parameters">Parameters</h6>

<ul>
<li><strong>ids</strong>:                  Either an array of motor IDs, or a single motor ID</li>
<li><strong>address</strong>:              Memory address for reading out command value in each Dynamixel motor.</li>
<li><strong>n_bytes</strong>:              Number of bytes that encode the command value (either 1, 2, or 4).</li>
<li><strong>two_comp_thres</strong>:       If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</li>
<li><strong>two_comp_sub</strong>:         If 2-complement representation of value exceeds two_comp_thres, then two_comp_sub will be subtracted from this value. Only if not None.</li>
</ul>
</div>


                            </div>
                </section>
    </main>
<script>
    /* Periodically check with the pdoc server if there have been any changes. */
    let mtime_generated = "1680636537.5",
        url = new URL(window.location);
    url.searchParams.set("mtime", 1);
    window.setInterval(function () {
        fetch(url.toString())
            .then(response => response.text())
            .then(mtime => {
                if (mtime_generated !== mtime)
                    location.reload();
            });
    }, 1000);
</script></body>
</html>